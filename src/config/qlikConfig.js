import React from 'react';
import globals from '../Util/qlikGlobals';
import Uid from '../Util/Uid';

const enigma = require('enigma.js');
const schema = require('enigma.js/schemas/12.20.0.json');
const SenseUtilities = require('enigma.js/sense-utilities');

let capabilityApisPromise;

/** Function to load Capability APIs from config*/
const loadCapabilityApis = async config => {
  try {
    if (capabilityApisPromise) {
      await capabilityApisPromise;
      return;
    }
    const capabilityApisJS = document.createElement('script');
    const prefix = config.prefix !== '' ? `/${config.prefix}` : '';
    capabilityApisJS.src = `${(config.isSecure ? 'https://' : 'http://') +
      config.host +
      (config.port ? `:${config.port}` : '') +
      prefix}/resources/assets/external/requirejs/require.js`;
    document.head.appendChild(capabilityApisJS);
    capabilityApisJS.loaded = new Promise(resolve => {
      capabilityApisJS.onload = () => {
        resolve();
      };
    });
    const capabilityApisCSS = document.createElement('link');
    capabilityApisCSS.href = `${(config.isSecure ? 'https://' : 'http://') +
      config.host +
      (config.port ? `:${config.port}` : '') +
      prefix}/resources/autogenerated/qlik-styles.css`;
    capabilityApisCSS.type = 'text/css';
    capabilityApisCSS.rel = 'stylesheet';
    document.head.appendChild(capabilityApisCSS);
    capabilityApisCSS.loaded = new Promise(resolve => {
      capabilityApisCSS.onload = () => {
        resolve();
      };
    });

    capabilityApisPromise = Promise.all([
      capabilityApisJS.loaded,
      capabilityApisCSS.loaded
    ]);

    await capabilityApisPromise;
  } catch (error) {
    throw new Error(error);
  }
};

/* Function to create App connection from config */
const qApp = async config => {
  try {
    await loadCapabilityApis(config);
    const prefix = config.prefix !== '' ? `/${config.prefix}/` : '/';
    window.require.config({
      baseUrl: `${(config.isSecure ? 'https://' : 'http://') +
        config.host +
        (config.port ? `:${config.port}` : '') +
        prefix}resources`,
      paths: {
        qlik: `${(config.isSecure ? 'https://' : 'http://') +
          config.host +
          (config.port ? `:${config.port}` : '') +
          prefix}resources/js/qlik`
      },
      config: {
        text: {
          useXhr() {
            return true;
          }
        }
      }
    });
    return new Promise(resolve => {
      if (globals.qlik) {
        const app = globals.qlik.openApp(config.appId, {
          ...config,
          isSecure: config.isSecure,
          prefix
        });
        resolve(app);
      } else {
        window.require(['js/qlik'], q => {
          globals.qlik = q;
          globals.resize = () => {
            q.resize();
          };
          const app = q.openApp(config.appId, {
            ...config,
            isSecure: config.isSecure,
            prefix
          });
          return resolve(app);
        });
      }
    });
  } catch (error) {
    throw new Error(error);
  }
};

/** Create connection to the engine API (qDoc) */

// const MAX_RETRIES = 3;

// const responseInterceptors = [
//   {
//     // We only want to handle failed responses from QIX Engine:
//     onRejected: function retryAbortedError(sessionReference, request, error) {
//       // We only want to handle aborted QIX errors:
//       if (
//         error.code === schema.enums.LocalizedErrorCode.LOCERR_GENERIC_ABORTED
//       ) {
//         // We keep track of how many consecutive times we have tried to do this call:
//         request.tries = (request.tries || 0) + 1;
//         // We do not want to get stuck in an infinite loop here if something has gone
//         // awry, so we only retry until we have reached MAX_RETRIES:
//         if (request.tries <= MAX_RETRIES) {
//           return request.retry();
//         }
//       }
//       // If it was not an aborted QIX call, or if we reached MAX_RETRIES, we let the error
//       // trickle down to potential other interceptors, and finally down to resolving/rejecting
//       // the initial promise that the user got when invoking the QIX method:
//       return this.Promise.reject(error);
//     }
//   }
// ];

const qDoc = async (config, open = true) => {
  const myConfig = config;
  const MAX_RETRIES = 3;

  const responseInterceptors = [
    {
      // We only want to handle failed responses from QIX Engine:
      onRejected: function retryAbortedError(sessionReference, request, error) {
        // We only want to handle aborted QIX errors:
        if (
          error.code === schema.enums.LocalizedErrorCode.LOCERR_GENERIC_ABORTED
        ) {
          // We keep track of how many consecutive times we have tried to do this call:
          request.tries = (request.tries || 0) + 1;
          // We do not want to get stuck in an infinite loop here if something has gone
          // awry, so we only retry until we have reached MAX_RETRIES:
          if (request.tries <= MAX_RETRIES) {
            return request.retry();
          }
        }
        // If it was not an aborted QIX call, or if we reached MAX_RETRIES, we let the error
        // trickle down to potential other interceptors, and finally down to resolving/rejecting
        // the initial promise that the user got when invoking the QIX method:
        return this.Promise.reject(error);
      }
    }
  ];
  // Make it work for Qlik Core scaling https://github.com/qlik-oss/core-scaling
  // qlikcore/engine:12.248.0
  if (myConfig.core) {
    myConfig.subpath = myConfig.prefix ? `${myConfig.prefix}/app` : 'app';
    myConfig.route = `doc/${myConfig.appId}`;
  }
  const url = SenseUtilities.buildUrl(myConfig);
  // const url = `wss://dash.condenast.com/app/`;
  const session = enigma.create({ schema, url, responseInterceptors });
  // const session = open ? enigma.create({ schema, url, responseInterceptors }) : enigma.create({ schema, responseInterceptors });
  const global = await session.open();
  globals.engine = global;
  globals.engineSession = session;
  // if (myConfig.core) {
  //   return global.getActiveDoc();
  // }

  if (open) {
    return global.openDoc(myConfig.appId);
  } else {
    return session;
  }
};

const TurnkeyCalcID = '59b08097-1b55-4227-b4cd-c306f414ab09'; // turnkey app with new calcs
const TurnkeyLogInAppID = 'e763d33b-a905-4ab8-be7a-0ff0af7a53a0'; // picker app

const config = {
  host: 'dash.condenast.com',
  isSecure: true,
  port: 443,
  prefix: '',
  identity: Uid(16),
  appId: TurnkeyLogInAppID
};

const sessionAppConfig = {
  ...config,
  appId: TurnkeyCalcID
};

const cApp = null;//qApp(config);
const eApp = qDoc(config, true);
const QlikContext = React.createContext({
  cApp,
  eApp
});

export {
  config,
  sessionAppConfig,
  TurnkeyLogInAppID,
  TurnkeyCalcID,
  qDoc,
  qApp,
  QlikContext
};
